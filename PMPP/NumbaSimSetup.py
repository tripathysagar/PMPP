"""Check if the Numba CUDA simulator is enabled"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_NumbaSimSetup.ipynb.

# %% auto 0
__all__ = ['cuda', 'has_gpu', 'is_sim', 'set_sim', 'device', 'test_close', 'dim', 'perf']

# %% ../nbs/00_NumbaSimSetup.ipynb 2
import os
import sys

# %% ../nbs/00_NumbaSimSetup.ipynb 4
import subprocess

def has_gpu():
    """Check if the system has a GPU using subprocess nvidia-smi."""
    try:
        subprocess.run(['nvidia-smi'], capture_output=True, check=True)
        return True
    except:
        return False

# %% ../nbs/00_NumbaSimSetup.ipynb 7
def is_sim():
    """Check if we're running in a simulator by checking the NUMBA_ENABLE_CUDASIM environment variable"""
    return os.environ.get('NUMBA_ENABLE_CUDASIM') == '1'

# %% ../nbs/00_NumbaSimSetup.ipynb 10
def set_sim():
    """ Seting up Numba CUDA simulator"""
    if not is_sim():
        os.environ['NUMBA_ENABLE_CUDASIM'] = '1'

# %% ../nbs/00_NumbaSimSetup.ipynb 14
if not has_gpu():
    set_sim()
from numba import cuda
cuda = cuda  # force nbdev to recognize it

# %% ../nbs/00_NumbaSimSetup.ipynb 15
from numba import cuda

# %% ../nbs/00_NumbaSimSetup.ipynb 19
def device(x):
    return "cuda" if hasattr(x, 'copy_to_host') else "cpu"

# %% ../nbs/00_NumbaSimSetup.ipynb 21
import numpy as np

def test_close(a, b, tol=1e-4):
    return np.allclose(a, b, rtol=tol, atol=tol)


# %% ../nbs/00_NumbaSimSetup.ipynb 23
import math
def dim(base:float, th:float):
    return math.ceil(base/th)

# %% ../nbs/00_NumbaSimSetup.ipynb 26
import time
from functools import wraps
from numba import cuda

def perf(warmup=2, iters=20):
    def decorator(fn):
        @wraps(fn)
        def wrapper(*args, **kwargs):
            # Warmup runs
            for _ in range(warmup):
                fn(*args, **kwargs)
            
            if is_sim():
                start = time.perf_counter()
                for _ in range(iters):
                    result = fn(*args, **kwargs)
                elapsed_ms = (time.perf_counter() - start) * 1000 / iters
            else:
                cuda.synchronize()
                
                start = cuda.event()
                end = cuda.event()
                elapsed_ms = 0
                
                for _ in range(iters):
                    start.record()
                    result = fn(*args, **kwargs)
                    end.record()
                    end.synchronize()
                    elapsed_ms += cuda.event_elapsed_time(start, end)
                
                elapsed_ms /= iters
            
            print(f"{fn.__name__}: {elapsed_ms:.4f} ms (avg of {iters} runs)")
            return result
        return wrapper
    return decorator

